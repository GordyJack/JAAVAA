import json
import re
from pathlib import Path

def generate_combined_model_files(bottom_half_model, top_half_model, output_dir):
    # Load the bottom half model
    with open(bottom_half_model, 'r') as file:
        bottom_model_json = json.load(file)
    
    # Load the top half model
    with open(top_half_model, 'r') as file:
        top_model_json = json.load(file)
    
    # Combine the elements of both models
    combined_elements = bottom_model_json.get('elements', []) + top_model_json.get('elements', [])
    
    # Create the composite model JSON structure
    composite_model_json = {
        "credit": "Generated by ModelCombiner.py",
        "parent": "block/block",
        "textures": {
            "particle": "#side"
        },
        "elements": combined_elements
    }
    
    # Ensure the output directory exists
    output_dir_path = Path(output_dir)
    output_dir_path.mkdir(parents=True, exist_ok=True)
    
    # Write the composite model to a new file
    output_model_name = generate_output_model_name(bottom_half_model, top_half_model)
    output_file_path = output_dir_path / f"{output_model_name}.json"
    with open(output_file_path, 'w') as file:
        json.dump(composite_model_json, file, indent=4)
        
def generate_output_model_name(bottom_half_model, top_half_model):
    """
    Generates the output model name based on the position information encoded in the input model file names,
    ignoring the type part of the filename.

    Parameters:
    - bottom_half_model: Filename of the bottom half model.
    - top_half_model: Filename of the top half model.

    Returns:
    - The generated output model name.
    """
    # Extract position info from file names using regex, ignoring the type part
    pattern = re.compile(r'mini_block_([01]{8})_[^.]+\.json')
    bottom_match = pattern.search(bottom_half_model)
    top_match = pattern.search(top_half_model)
    
    if not bottom_match or not top_match:
        raise ValueError("Invalid model file name format.")
    
    # Convert position info from binary string to integers and combine using bitwise OR
    bottom_position = int(bottom_match.group(1), 2)
    top_position = int(top_match.group(1), 2)
    combined_position = bottom_position | top_position
    
    # Generate the output model file name
    output_model_name = f"mini_block_{combined_position:08b}"
    
    return output_model_name
    

# Current script location
script_path = Path(__file__).parent

# Calculate the relative path to the model files
# Move up to the project root (src/main/java/net/gordyjack/jamba/data/pythonScripts -> src)
project_root = script_path.parents[5]

# Define the path to the model files relative to the project root
model_files_path = f'{project_root}/resources/assets/jamba/models/block/'
output_files_path = f'{project_root}/generated/assets/jamba/models/block/'

print(model_files_path, output_files_path)

bottom_model_files = [
    "mini_block_00000001_single.json",
    "mini_block_00000011_dual_straight.json",
    "mini_block_00001001_dual_diagonal.json",
    "mini_block_00001011_triple.json",
    "mini_block_00001111_quad_slab.json"
]
top_model_files = [
    "mini_block_00010000_single.json",
    "mini_block_00110000_dual_straight.json",
    "mini_block_10010000_dual_diagonal.json",
    "mini_block_10110000_triple.json",
    "mini_block_11110000_quad_slab.json"
]
for bottom_file in bottom_model_files:
    for top_file in top_model_files:
        generate_combined_model_files(model_files_path + bottom_file, model_files_path + top_file, output_files_path)


print("Success")
